// frontend/utils/myFetch.ts

// Variable global para evitar múltiples alert/logout simultáneos
let isLoggingOut = false;

export async function myFetch(
  endpoint: string,
  options: RequestInit = {}
): Promise<any> {

  // Helper interno para logout
  function logoutUser() {
    window.localStorage.removeItem('token');
    window.localStorage.removeItem('role');
    window.location.href = '/';
  }

  // 1) Obtener token de localStorage
  const token = window.localStorage.getItem('token');

  // 2) Construir headers con Authorization si hay token
  const finalHeaders = new Headers(options.headers || {});
  if (token) {
    finalHeaders.set('Authorization', `Bearer ${token}`);
  }

  // 3) Armar la URL completa (BACKEND_URL + endpoint)
  const fullUrl = `${process.env.NEXT_PUBLIC_BACKEND_URL}${endpoint}`;

  try {
    // 4) Hacemos el fetch
    const response = await fetch(fullUrl, {
      ...options,
      headers: finalHeaders,
    });

    // 5) Manejo de 401/403 => sesión expirada o no autorizada
    if (response.status === 401 || response.status === 403) {
      // Evitar múltiples alert en paralelo
      if (!isLoggingOut) {
        isLoggingOut = true;
        alert('Your session has expired. Please log in again.');
        logoutUser();
      }
      // En vez de throw => devolvemos un objeto error
      return {
        status: 'error',
        message: 'Session expired or not authorized.',
      };
    }

    // 6) Ver si hubo otro error (4xx o 5xx)
    if (!response.ok) {
      // Intentamos parsear error
      const errData = await response.json().catch(() => ({}));
      const msg = errData.error || 'Request error';
      return {
        status: 'error',
        message: msg,
      };
    }

    // 7) Check if this is an SSE response
    const contentType = response.headers.get('content-type');
    if (contentType && contentType.includes('text/event-stream')) {
      let resultData = '';
      const reader = response.body?.getReader();
      if (!reader) return { status: 'error', message: 'Could not read response stream' };

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        const chunk = new TextDecoder('utf-8').decode(value);
        resultData += chunk;
      }

      // Parse the accumulated data
      const parsedData = parseSSEData(resultData);
      return {
        status: 'ok',
        data: parsedData,
      };
    } else {
      // If it's not SSE, handle it as regular JSON
      const data = await response.json().catch(() => ({}));
      return {
        status: 'ok',
        data,
      };
    }

  } catch (error) {
    console.error('Error in myFetch:', error);
    return {
      status: 'error',
      message: String(error),
    };
  }
}

// Helper function to parse SSE data
function parseSSEData(data: string) {
  return data.split('\n\n').reduce((accum, chunk) => {
    if (chunk.startsWith('data: ')) {
      try {
        const jsonData = JSON.parse(chunk.slice(6));
        if (jsonData.assistantContent) {
          accum.assistantContent = (accum.assistantContent || '') + jsonData.assistantContent;
        }
      } catch (parseError) {
        console.error('Failed to parse SSE chunk:', parseError, 'Chunk:', chunk);
      }
    }
    return accum;
  }, {} as { assistantContent?: string });
}
